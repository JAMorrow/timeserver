//Login Package
//
// Manages the Logged in users as well as checking the cookies that
// are related to those logins
package Login

import (
	"sync"
	"errors"
	"net/http"
	"os/exec"
)

// Structure for maintaining Authentication of users
type Users struct{
	Dict    map[string]string
	Lock    sync.RWMutex
}

var (
	users Users
)
// checks the list for the given name, returns a name and nil if found
// returns "" and an error if not found
func (Users) CheckUser(r *http.Request) (string, error) {

	// get the cookie
	cookie, err := r.Cookie("UID")
	if err == nil {
		// check the map for the user
		users.Lock.RLock()

		if users.Dict == nil {
			users.Dict = make(map[string]string)
		}
		val, ok := users.Dict[cookie.Value]
		users.Lock.RUnlock()
		if ok {
			// user found
			return val, nil
			
		} else {

			// no user found with found cookie
			return "", errors.New("No user found")
		}
	}
	// the function should have returned by, so return error
	return "", errors.New("No cookie found\r\n")

}

// adds the given name to the map, and adds the cookie to the http client
// It is assumed that the input name is valid at this point in the code
func (Users) AddUser(w http.ResponseWriter, name string) (error) {

	// windows exe included in file
	cmd := exec.Command("Uuidgen.Exe")

	// Get a new UID
	//cmd := exec.Command("/usr/bin/uuidgen")
	uui, err := cmd.Output()
	uid := string(uui)
	uid = uid[:len(uid)-2]
	
	cookie := http.Cookie{Name: "UID", Value: uid, Path: "/"}
	http.SetCookie(w, &cookie)

	if err == nil {
		// Set up cookie jar
		if users.Dict == nil {
			users.Dict = make(map[string]string)
		}

		users.Lock.Lock()
		users.Dict[uid] = name
		users.Lock.Unlock()

		return nil
	} else {
		return errors.New("Uuidgen generation error")
	}

}

func (Users) ClearCookie(w http.ResponseWriter, r *http.Request) {

	// Determine if a cookie is present
	cookie, err := r.Cookie("UID")
	
	if err == nil {
		cookie.MaxAge = -1
		http.SetCookie(w, cookie)

	// clear out name
	}


}
